/**
 * Service Worker for Lex Talionis Web — enables offline play.
 *
 * Strategy:
 * - App shell (HTML, JS, CSS): precached on install from precache-manifest.json
 *   (generated by Vite build plugin), then stale-while-revalidate at runtime
 * - Game data (.ltproj assets): cache-first, populated by the asset bundler or on-demand
 * - Audio/images: cache-first after first fetch
 * - API/external: network-first with cache fallback
 *
 * The cache is versioned — bump CACHE_VERSION to force a full refresh.
 */

const CACHE_VERSION = 'lt-web-v2';
const APP_CACHE = `${CACHE_VERSION}-app`;
const ASSET_CACHE = `${CACHE_VERSION}-assets`;

/** Fallback app shell URLs to precache when no manifest is available (dev mode). */
const FALLBACK_APP_SHELL = [
  '/',
  '/index.html',
  '/manifest.json',
  '/icons/icon-192.png',
  '/icons/icon-512.png',
];

/**
 * File extensions that belong in the long-lived asset cache.
 * These are game data files that rarely change.
 */
const ASSET_EXTENSIONS = [
  '.png', '.jpg', '.jpeg', '.gif', '.webp',
  '.ogg', '.mp3', '.wav',
  '.json',
  '.idx', '.txt',
];

// ---------------------------------------------------------------------------
// Install — precache app shell (from manifest or fallback)
// ---------------------------------------------------------------------------

self.addEventListener('install', (event) => {
  event.waitUntil(
    (async () => {
      const cache = await caches.open(APP_CACHE);

      // Try to load the Vite-generated precache manifest
      let urls = FALLBACK_APP_SHELL;
      try {
        const manifestResponse = await fetch('/precache-manifest.json');
        if (manifestResponse.ok) {
          const manifest = await manifestResponse.json();
          urls = manifest.map((entry) => entry.url);
          console.info(`[SW] Precaching ${urls.length} files from manifest`);
        }
      } catch {
        console.info('[SW] No precache manifest found, using fallback app shell');
      }

      // Cache all URLs (non-fatal on individual failures)
      const results = await Promise.allSettled(
        urls.map((url) =>
          fetch(url).then((response) => {
            if (response.ok) {
              return cache.put(url, response);
            }
          })
        )
      );
      const failed = results.filter((r) => r.status === 'rejected').length;
      if (failed > 0) {
        console.warn(`[SW] Precache: ${failed}/${urls.length} files failed`);
      }

      await self.skipWaiting();
    })()
  );
});

// ---------------------------------------------------------------------------
// Activate — clean up old caches
// ---------------------------------------------------------------------------

self.addEventListener('activate', (event) => {
  event.waitUntil(
    caches.keys().then((keys) => {
      return Promise.all(
        keys
          .filter((key) => key !== APP_CACHE && key !== ASSET_CACHE)
          .map((key) => caches.delete(key))
      );
    }).then(() => self.clients.claim())
  );
});

// ---------------------------------------------------------------------------
// Fetch — routing
// ---------------------------------------------------------------------------

self.addEventListener('fetch', (event) => {
  const url = new URL(event.request.url);

  // Only handle same-origin requests
  if (url.origin !== self.location.origin) return;

  // Skip non-GET requests
  if (event.request.method !== 'GET') return;

  // Navigation requests (HTML pages) — serve index.html from cache for SPA
  if (event.request.mode === 'navigate') {
    event.respondWith(
      caches.match('/index.html', { cacheName: APP_CACHE }).then((cached) => {
        return cached || fetch(event.request);
      }).catch(() => {
        return new Response('Offline — app not cached', {
          status: 503,
          headers: { 'Content-Type': 'text/plain' },
        });
      })
    );
    return;
  }

  // Determine if this is a game asset
  const isAsset = isGameAsset(url.pathname);

  if (isAsset) {
    // Game assets: cache-first, fall back to network
    event.respondWith(cacheFirst(event.request, ASSET_CACHE));
  } else {
    // App shell / JS bundles: stale-while-revalidate
    event.respondWith(staleWhileRevalidate(event.request, APP_CACHE));
  }
});

// ---------------------------------------------------------------------------
// Caching strategies
// ---------------------------------------------------------------------------

/**
 * Cache-first: return cached response if available, otherwise fetch and cache.
 */
async function cacheFirst(request, cacheName) {
  const cache = await caches.open(cacheName);
  const cached = await cache.match(request);
  if (cached) return cached;

  try {
    const response = await fetch(request);
    if (response.ok) {
      cache.put(request, response.clone());
    }
    return response;
  } catch (err) {
    // Offline and not cached — return a basic offline response
    return new Response('Offline — asset not cached', {
      status: 503,
      statusText: 'Service Unavailable',
    });
  }
}

/**
 * Stale-while-revalidate: return cached immediately, update cache in background.
 */
async function staleWhileRevalidate(request, cacheName) {
  const cache = await caches.open(cacheName);
  const cached = await cache.match(request);

  const fetchPromise = fetch(request).then((response) => {
    if (response.ok) {
      cache.put(request, response.clone());
    }
    return response;
  }).catch(() => {
    // Network failed, that's fine if we have a cached version
    return cached || new Response('Offline', { status: 503 });
  });

  // Return cached immediately if available, otherwise wait for network
  return cached || fetchPromise;
}

// ---------------------------------------------------------------------------
// Message handling — for cache management from the app
// ---------------------------------------------------------------------------

self.addEventListener('message', (event) => {
  const { type, payload } = event.data || {};

  switch (type) {
    case 'CACHE_ASSETS': {
      // Bulk-cache a list of asset URLs (used by the asset bundler)
      event.waitUntil(cacheAssets(payload.urls || []));
      break;
    }
    case 'CLEAR_ASSET_CACHE': {
      event.waitUntil(caches.delete(ASSET_CACHE));
      break;
    }
    case 'GET_CACHE_SIZE': {
      getCacheSize().then((size) => {
        event.ports[0]?.postMessage({ type: 'CACHE_SIZE', size });
      });
      break;
    }
    case 'SKIP_WAITING': {
      self.skipWaiting();
      break;
    }
  }
});

/**
 * Cache a list of asset URLs into the asset cache.
 */
async function cacheAssets(urls) {
  const cache = await caches.open(ASSET_CACHE);
  const results = await Promise.allSettled(
    urls.map((url) =>
      fetch(url).then((response) => {
        if (response.ok) {
          return cache.put(url, response);
        }
      })
    )
  );
  const failed = results.filter((r) => r.status === 'rejected').length;
  if (failed > 0) {
    console.warn(`[SW] Failed to cache ${failed}/${urls.length} assets`);
  }
}

/**
 * Estimate total cache size across all caches.
 */
async function getCacheSize() {
  if ('storage' in navigator && 'estimate' in navigator.storage) {
    const estimate = await navigator.storage.estimate();
    return { usage: estimate.usage || 0, quota: estimate.quota || 0 };
  }
  return { usage: 0, quota: 0 };
}

// ---------------------------------------------------------------------------
// Helpers
// ---------------------------------------------------------------------------

function isGameAsset(pathname) {
  // /game-data/ paths are always game assets
  if (pathname.startsWith('/game-data/')) return true;

  // Check file extension
  const ext = pathname.slice(pathname.lastIndexOf('.'));
  return ASSET_EXTENSIONS.includes(ext);
}
